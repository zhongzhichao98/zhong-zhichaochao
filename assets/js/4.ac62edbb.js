(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{365:function(t,s,a){t.exports=a.p+"assets/img/200(1).048aadb7.png"},366:function(t,s,a){t.exports=a.p+"assets/img/200(2).973df945.png"},367:function(t,s,a){t.exports=a.p+"assets/img/200(3).2c1057ca.png"},368:function(t,s,a){t.exports=a.p+"assets/img/200(4).16c8a423.png"},369:function(t,s,a){t.exports=a.p+"assets/img/200(5).a41555f9.png"},370:function(t,s,a){t.exports=a.p+"assets/img/200(6).56a3f654.png"},371:function(t,s,a){t.exports=a.p+"assets/img/200(7).94f2be84.png"},372:function(t,s,a){t.exports=a.p+"assets/img/200(8).c342488f.png"},373:function(t,s,a){t.exports=a.p+"assets/img/200(9).f0397ff4.png"},374:function(t,s,a){t.exports=a.p+"assets/img/200(10).0f20486e.png"},375:function(t,s,a){t.exports=a.p+"assets/img/200(11).33d76441.png"},376:function(t,s,a){t.exports=a.p+"assets/img/200(12).d3734098.png"},377:function(t,s,a){t.exports=a.p+"assets/img/200(13).9b8708fc.png"},378:function(t,s,a){t.exports=a.p+"assets/img/200(14).00a9b54d.png"},379:function(t,s,a){t.exports=a.p+"assets/img/200(15).c21a7d5f.png"},380:function(t,s,a){t.exports=a.p+"assets/img/200(16).506d0272.png"},381:function(t,s,a){t.exports=a.p+"assets/img/200(17).1b0e6f33.png"},382:function(t,s,a){t.exports=a.p+"assets/img/200(18).3f85ac88.png"},383:function(t,s,a){t.exports=a.p+"assets/img/200(19).142a9dfc.png"},384:function(t,s,a){t.exports=a.p+"assets/img/200(20).ba058127.png"},385:function(t,s,a){t.exports=a.p+"assets/img/200(21).a61b777c.png"},386:function(t,s,a){t.exports=a.p+"assets/img/200(22).68712a9f.png"},387:function(t,s,a){t.exports=a.p+"assets/img/200(23).353244d3.png"},388:function(t,s,a){t.exports=a.p+"assets/img/200(24).3bf27c30.png"},389:function(t,s,a){t.exports=a.p+"assets/img/200(25).48dff1d3.png"},390:function(t,s,a){t.exports=a.p+"assets/img/200(26).b0c75b6c.png"},391:function(t,s,a){t.exports=a.p+"assets/img/200(27).73732a1c.png"},392:function(t,s,a){t.exports=a.p+"assets/img/200(28).05caba91.png"},393:function(t,s,a){t.exports=a.p+"assets/img/200(29).de83360b.png"},394:function(t,s,a){t.exports=a.p+"assets/img/200(30).b71669db.png"},503:function(t,s,a){"use strict";a.r(s);var r=a(10),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"_1-vue3-ts开发环境创建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue3-ts开发环境创建"}},[t._v("#")]),t._v(" 1. Vue3 + TS开发环境创建")]),t._v(" "),s("h3",{attrs:{id:"_1-创建环境"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-创建环境"}},[t._v("#")]),t._v(" 1. 创建环境")]),t._v(" "),s("p",[t._v("vite除了支持基础阶段的纯TS环境之外，还支持 Vue + TS开发环境的快速创建, 命令如下：")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" create vite@latest  vue-ts-pro -- "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--template")]),t._v(" vue-ts \n")])])]),s("p",[t._v("说明：")]),t._v(" "),s("ol",[s("li",[t._v("npm create vite"),s("a",{attrs:{href:"/latest"}},[t._v("@latest ")]),t._v("   基于最新版本的vite进行项目创建")]),t._v(" "),s("li",[t._v("vue-ts-pro    项目名称")]),t._v(" "),s("li",[t._v("-- --template vue-ts    选择Vue + TS的开发模板")])]),t._v(" "),s("h3",{attrs:{id:"_2-和-vue文件相关的工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-和-vue文件相关的工具"}},[t._v("#")]),t._v(" 2. 和.vue文件相关的工具")]),t._v(" "),s("p",[s("strong",[t._v("开发阶段")])]),t._v(" "),s("ol",[s("li",[t._v("Volar工具对.vue文件进行实时的类型错误反馈")]),t._v(" "),s("li",[t._v("TypeScript Vue Plugin 工具用于支持在 TS 中 import *.vue 文件")])]),t._v(" "),s("p",[s("strong",[t._v("打包阶段")]),t._v("\nvue-tsc工具负责打包时最终的类型检查\n"),s("img",{attrs:{src:a(365),alt:"image.png"}}),t._v("\n好处：开发阶段的类型提示交给IDE做，保证vite的运行速度，打包阶段做’兜底类型校验’，确保类型无误")]),t._v(" "),s("h2",{attrs:{id:"_2-为ref标注类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-为ref标注类型"}},[t._v("#")]),t._v(" 2. 为Ref标注类型")]),t._v(" "),s("h3",{attrs:{id:"_1-场景和好处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-场景和好处"}},[t._v("#")]),t._v(" 1. 场景和好处")]),t._v(" "),s("p",[t._v("为ref标注类型之后，既可以在给ref对象的value赋值时校验数据类型，同时在使用value的时候可以获得代码提示\n"),s("img",{attrs:{src:a(366),alt:"9.png"}}),t._v("\n说明：本质上是给ref对象的value属性添加类型约束")]),t._v(" "),s("h3",{attrs:{id:"_2-如何标注"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何标注"}},[t._v("#")]),t._v(" 2. 如何标注")]),t._v(" "),s("p",[t._v("ref 函数和 TS 的配合通常分为俩种情况，类型推导和泛型指定类型")]),t._v(" "),s("ol",[s("li",[t._v("如果是简单的数据，推荐使用类型推导\n"),s("img",{attrs:{src:a(367),alt:"11.png"}})]),t._v(" "),s("li",[t._v("如果是较复杂的数据，通过泛型指定类型\n"),s("img",{attrs:{src:a(368),alt:"12.png"}})])]),t._v(" "),s("h3",{attrs:{id:"_3-思考题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-思考题"}},[t._v("#")]),t._v(" 3. 思考题")]),t._v(" "),s("p",[t._v("标注ref函数类型，可以满足把下图所示的数据赋值给value属性\n"),s("img",{attrs:{src:a(369),alt:"16.png"}})]),t._v(" "),s("h2",{attrs:{id:"_3-为事件处理函数标注类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-为事件处理函数标注类型"}},[t._v("#")]),t._v(" 3. 为事件处理函数标注类型")]),t._v(" "),s("h3",{attrs:{id:"_1-为什么需要标注类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么需要标注类型"}},[t._v("#")]),t._v(" 1. 为什么需要标注类型")]),t._v(" "),s("p",[t._v("原生dom事件处理函数的参数默认会自动标注为any类型，没有任何类型提示，为了获得良好的类型提示，需要手动标注类型\n"),s("img",{attrs:{src:a(370),alt:"1.png"}})]),t._v(" "),s("h3",{attrs:{id:"_2-如何标注类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何标注类型"}},[t._v("#")]),t._v(" 2. 如何标注类型")]),t._v(" "),s("ol",[s("li",[t._v("给事件对象形参 e 标注为Event类型，可以获得事件对象的相关类型提示\n"),s("img",{attrs:{src:a(371),alt:"3.png"}})]),t._v(" "),s("li",[t._v("如果需要更加精确的DOM类型提示可以使用断言（as）进行操作\n"),s("img",{attrs:{src:a(372),alt:"12.png"}})])]),t._v(" "),s("h2",{attrs:{id:"_4-为模版引用标注类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-为模版引用标注类型"}},[t._v("#")]),t._v(" 4. 为模版引用标注类型")]),t._v(" "),s("h3",{attrs:{id:"_1-为什么需要类型标注"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么需要类型标注"}},[t._v("#")]),t._v(" 1. 为什么需要类型标注")]),t._v(" "),s("p",[t._v("给模版引用标注类型，本质上是给ref对象的value属性添加了类型约束，约定value属性中存放的是特定类型的DOM对象，从而在使用的时候获得相应的代码提示")]),t._v(" "),s("p",[s("img",{attrs:{src:a(373),alt:"4.png"}})]),t._v(" "),s("h3",{attrs:{id:"_2-如何进行类型标注"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何进行类型标注"}},[t._v("#")]),t._v(" 2. 如何进行类型标注")]),t._v(" "),s("p",[t._v("通过具体的DOM类型联合null做为泛型参数, 比如我们想获取一个input dom元素\n"),s("img",{attrs:{src:a(374),alt:"5.png"}})]),t._v(" "),s("h3",{attrs:{id:"_3-思考题-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-思考题-2"}},[t._v("#")]),t._v(" 3. 思考题")]),t._v(" "),s("p",[t._v("尝试为模版引用标注类型获取一个a元素？")]),t._v(" "),s("h2",{attrs:{id:"_5-对象的非空值处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-对象的非空值处理"}},[t._v("#")]),t._v(" 5. 对象的非空值处理")]),t._v(" "),s("h3",{attrs:{id:"_1-空值场景说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-空值场景说明"}},[t._v("#")]),t._v(" 1. 空值场景说明")]),t._v(" "),s("p",[t._v("当对象的属性可能是 null 或 undefined 的时候，称之为“空值”，尝试访问空值身上的属性或者方法会发生类型错误\n"),s("img",{attrs:{src:a(375),alt:"6.png"}}),t._v("\n说明：inputRef变量在组件挂载完毕之前，value属性中存放的值为null，不是input dom对象，通不过类型校验")]),t._v(" "),s("h3",{attrs:{id:"_2-可选链方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-可选链方案"}},[t._v("#")]),t._v(" 2. 可选链方案")]),t._v(" "),s("p",[t._v("可选链 ?. 是一种访问嵌套对象属性的安全的方式, 可选链前面的值为 undefined 或者 null时，它会停止运算\n"),s("img",{attrs:{src:a(376),alt:"1.png"}})]),t._v(" "),s("h3",{attrs:{id:"_3-逻辑判断方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-逻辑判断方案"}},[t._v("#")]),t._v(" 3. 逻辑判断方案")]),t._v(" "),s("p",[t._v("通过逻辑判断，只有有值的时候才继续执行后面的属性访问语句\n"),s("img",{attrs:{src:a(377),alt:"2.png"}})]),t._v(" "),s("h3",{attrs:{id:"_4-非空断言方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-非空断言方案"}},[t._v("#")]),t._v(" 4. 非空断言方案")]),t._v(" "),s("p",[t._v("非空断言（!）是指我们开发者明确知道当前的值一定不是null或者undefined，让TS通过类型校验\n"),s("img",{attrs:{src:a(378),alt:"5.png"}}),t._v("\n**特别注意：**使用非空断言要格外小心，它没有实际的JS判断逻辑，只是通过了TS的类型校验，容易直接把空值出现在实际的执行环境里")]),t._v(" "),s("h2",{attrs:{id:"_6-为组件的props标注类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-为组件的props标注类型"}},[t._v("#")]),t._v(" 6. 为组件的Props标注类型")]),t._v(" "),s("h3",{attrs:{id:"_1-为什么给props标注类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么给props标注类型"}},[t._v("#")]),t._v(" 1. 为什么给Props标注类型")]),t._v(" "),s("p",[t._v("给组件的Props标注类型有俩个作用，一个是确保传递的prop是类型安全的，另一个在组件内部使用的时候也会有类型提示\n"),s("img",{attrs:{src:a(379),alt:"1.png"}})]),t._v(" "),s("p",[s("img",{attrs:{src:a(380),alt:"4.png"}})]),t._v(" "),s("h3",{attrs:{id:"_2-基础使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-基础使用"}},[t._v("#")]),t._v(" 2. 基础使用")]),t._v(" "),s("p",[t._v("语法：通过defineProps宏函数对组件props进行类型标注\n需求：按钮组件有俩个prop参数，color类型为string且为必填，size类型为string且为可选，怎么定义类型？\n"),s("img",{attrs:{src:a(381),alt:"5.png"}}),t._v("\n说明：按钮组件传递prop属性的时候必须满足color是必传项且类型为string, size为可选属性，类型为string")]),t._v(" "),s("h3",{attrs:{id:"_3-props默认值设置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-props默认值设置"}},[t._v("#")]),t._v(" 3. Props默认值设置")]),t._v(" "),s("p",[t._v("场景：Props中的可选参数通常除了指定类型之外还需要提供默认值，可以使用withDefaults宏函数来进行设置\n需求：按钮组件的size属性的默认值设置为 middle\n"),s("img",{attrs:{src:a(382),alt:"7.png"}}),t._v("\n说明：如果用户传递了size属性，按照传递的数据来，如果没有传递，则size值为 ’middle’")]),t._v(" "),s("h3",{attrs:{id:"_4-思考题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-思考题"}},[t._v("#")]),t._v(" 4. 思考题")]),t._v(" "),s("p",[t._v("给按钮组件添加一个btnType属性，类型为 ’success‘, ‘danger’ 或者 ’warning‘ 三选一, 默认值为 ’success‘")]),t._v(" "),s("h2",{attrs:{id:"_7-为组件的emits标注类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-为组件的emits标注类型"}},[t._v("#")]),t._v(" 7. 为组件的emits标注类型")]),t._v(" "),s("h3",{attrs:{id:"_1-为什么需要标注类型-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么需要标注类型-2"}},[t._v("#")]),t._v(" 1. 为什么需要标注类型")]),t._v(" "),s("p",[s("img",{attrs:{src:a(383),alt:"9.png"}}),t._v("\n作用：可以约束事件名称并给出自动提示，确保不会拼写错误，同时约束传参类型，不会发生参数类型错误")]),t._v(" "),s("h3",{attrs:{id:"_2-何为组件的emits标注类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-何为组件的emits标注类型"}},[t._v("#")]),t._v(" 2. 何为组件的emits标注类型")]),t._v(" "),s("p",[t._v("语法：通过 defineEmits 宏函数进行类型标注\n需求：子组件触发一个名称为 ’get-msg‘ 的事件，并且传递一个类型为string的参数\n"),s("img",{attrs:{src:a(384),alt:"8.png"}})]),t._v(" "),s("h3",{attrs:{id:"_3-思考题-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-思考题-3"}},[t._v("#")]),t._v(" 3. 思考题")]),t._v(" "),s("p",[t._v("Son组件再触发一个事件’get-list’, 传递参数类型为下图所示的数据类型\n"),s("img",{attrs:{src:a(385),alt:"11.png"}})]),t._v(" "),s("h2",{attrs:{id:"_8-类型声明文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-类型声明文件"}},[t._v("#")]),t._v(" 8. 类型声明文件")]),t._v(" "),s("h3",{attrs:{id:"_1-什么是类型声明文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是类型声明文件"}},[t._v("#")]),t._v(" 1. 什么是类型声明文件")]),t._v(" "),s("p",[t._v("概念：在TS中以d.ts为后缀的文件就是类型声明文件，主要作用是为js模块提供类型信息支持，从而获得类型提示\n"),s("img",{attrs:{src:a(386),alt:"image.png"}})]),t._v(" "),s("p",[t._v("说明：")]),t._v(" "),s("ol",[s("li",[t._v("d.ts是如何生效的？\n在使用js某些模块的时候，TS会自动导入模块对应的d.ts文件，以提供类型提示")]),t._v(" "),s("li",[t._v("d.ts是怎么来的？\n库如果本身是使用TS编写的，在打包的时候经过配置自动生成对应的d.ts文件（axios本身就是TS编写的）")])]),t._v(" "),s("h3",{attrs:{id:"_2-使用-definitelytyped-提供类型声明文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用-definitelytyped-提供类型声明文件"}},[t._v("#")]),t._v(" 2. 使用 DefinitelyTyped 提供类型声明文件")]),t._v(" "),s("p",[t._v("场景：有些库本身并不是采用TS编写的，无法直接生成配套的d.ts文件，但是也想获得类型提示，此时需要 Definitely Typed 提供类型声明文件\n"),s("img",{attrs:{src:a(387),alt:"image.png"}})]),t._v(" "),s("p",[t._v("DefinitelyTyped是一个TS类型定义的仓库，专门为JS编写的库可以提供类型声明，比如可以安装 @types/jquery 为jquery提供类型提示\n"),s("img",{attrs:{src:a(388),alt:"image.png"}})]),t._v(" "),s("h3",{attrs:{id:"_3-ts内置类型声明文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-ts内置类型声明文件"}},[t._v("#")]),t._v(" 3. TS内置类型声明文件")]),t._v(" "),s("p",[t._v("TS为JS运行时可用的所有标准化内置API都提供了声明文件，这些文件既不需要编译生成，也不需要三方提供")]),t._v(" "),s("p",[s("img",{attrs:{src:a(389),alt:"image.png"}})]),t._v(" "),s("p",[t._v("说明：这里的lib.es5.d.ts以及lib.dom.d.ts都是内置的类型声明文件，为原生js和浏览器API提供类型提示")]),t._v(" "),s("h3",{attrs:{id:"_4-自定义类型声明文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-自定义类型声明文件"}},[t._v("#")]),t._v(" 4. 自定义类型声明文件")]),t._v(" "),s("p",[t._v("d.ts文件在项目中是可以进行自定义创建的，通常有俩种作用，第一个是共享TS类型（重要），第二种是给js文件提供类型（了解）")]),t._v(" "),s("p",[s("strong",[t._v("场景一：共享TS类型")])]),t._v(" "),s("p",[s("img",{attrs:{src:a(390),alt:"image.png"}})]),t._v(" "),s("p",[t._v("说明：哪个业务组件需要用到类型导入即可，为了区分普通模块，可以加上type关键词")]),t._v(" "),s("p",[s("strong",[t._v("场景二：给JS文件提供类型")]),t._v(" "),s("img",{attrs:{src:a(391),alt:"image.png"}})]),t._v(" "),s("p",[t._v("说明：通过declare关键词可以为js文件中的变量声明对应类型，这样js导出的模块在使用的时候也会获得类型提示")]),t._v(" "),s("h3",{attrs:{id:"_5-ts文件和d-ts文件对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-ts文件和d-ts文件对比"}},[t._v("#")]),t._v(" 5. .ts文件和d.ts文件对比")]),t._v(" "),s("p",[t._v("TS中有俩种文件类型，一种是.ts文件，一种是.d.ts文件\n.ts文件")]),t._v(" "),s("ol",[s("li",[t._v("既可以包含类型信息也可以写逻辑代码")]),t._v(" "),s("li",[t._v("可以被编译为js文件")])]),t._v(" "),s("p",[t._v(".d.ts文件")]),t._v(" "),s("ol",[s("li",[t._v("只能包含类型信息不可以写逻辑代码")]),t._v(" "),s("li",[t._v("不会被编译为js文件，仅做类型校验检查")])]),t._v(" "),s("h2",{attrs:{id:"_9-综合案例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-综合案例"}},[t._v("#")]),t._v(" 9. 综合案例")]),t._v(" "),s("p",[s("img",{attrs:{src:a(392),alt:"image.png"}})]),t._v(" "),s("h3",{attrs:{id:"_1-克隆项目"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-克隆项目"}},[t._v("#")]),t._v(" 1. 克隆项目")]),t._v(" "),s("p",[t._v("项目的初始化配置已经完成，其中包括：")]),t._v(" "),s("ol",[s("li",[t._v("基于Vite搭建的基础的 Vue3 + TS 开发环境")]),t._v(" "),s("li",[t._v("请求库 axios")]),t._v(" "),s("li",[t._v("移动端组件库Vant")]),t._v(" "),s("li",[t._v("静态结构组件模板")])]),t._v(" "),s("p",[t._v("以下是项目地址，直接克隆项目安装依赖并run起来")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v("  clone http://git.itcast.cn/heimaqianduan/vue3-ts.git\n")])])]),s("h3",{attrs:{id:"_2-频道列表渲染-类型思想转变"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-频道列表渲染-类型思想转变"}},[t._v("#")]),t._v(" 2. 频道列表渲染 - 类型思想转变")]),t._v(" "),s("p",[t._v("之前业务开发我们用的是JavaScript，现在要加上TypeScript的类型，该如何把类型加进来呢？\n"),s("img",{attrs:{src:a(393),alt:"image.png"}})]),t._v(" "),s("p",[t._v("核心思想：使用TS之后的业务开发思想是保持一致的，重要的是根据接口格式定义响应式数据的类型以及axios返回数据的类型即可")]),t._v(" "),s("h3",{attrs:{id:"_3-频道列表渲染-定义axios的返回数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-频道列表渲染-定义axios的返回数据类型"}},[t._v("#")]),t._v(" 3. 频道列表渲染 - 定义axios的返回数据类型")]),t._v(" "),s("p",[t._v("定义axios的返回数据类型需要配合一个axios的request方法通过泛型指定")]),t._v(" "),s("p",[s("img",{attrs:{src:a(394),alt:"image.png"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/274425/1680087381288-1d8dcdc9-7e17-4e70-bda4-e3fcc97421fc.png#averageHue=%239f9a66&clientId=u84bbf5d8-8668-4&from=paste&height=333&id=u68a5fca3&name=image.png&originHeight=666&originWidth=2576&originalType=binary&ratio=2&rotation=0&showTitle=false&size=220375&status=done&style=none&taskId=ua1b932ed-2125-49aa-900e-a78e1959f85&title=&width=1288",alt:"image.png"}})]),t._v(" "),s("p",[t._v("说明: 我们通过泛型参数传给request方法的ChannelRes类型约束了axios返回值res的data属性的类型")]),t._v(" "),s("h3",{attrs:{id:"_4-文章列表渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-文章列表渲染"}},[t._v("#")]),t._v(" 4. 文章列表渲染")]),t._v(" "),s("p",[t._v("基础文章列表实现（固定频道id）")]),t._v(" "),s("ol",[s("li",[t._v("根据接口格式定义数据类型")]),t._v(" "),s("li",[t._v("使用 ref 函数定义响应式数据")]),t._v(" "),s("li",[t._v("使用 axios 请求数据并赋值给响应式数据")]),t._v(" "),s("li",[t._v("数据绑定到模版显示")])]),t._v(" "),s("p",[t._v("频道和文章列表联动实现（切换不同的频道id）")]),t._v(" "),s("ol",[s("li",[t._v("为List组件定义 props 类型")]),t._v(" "),s("li",[t._v("传递当前频道的 id，使用当前id获取列表")])])])}),[],!1,null,null,null);s.default=e.exports}}]);